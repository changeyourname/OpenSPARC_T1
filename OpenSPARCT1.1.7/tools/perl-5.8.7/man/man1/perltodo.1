.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.3
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLTODO 1"
.TH PERLTODO 1 "2005-05-29" "perl v5.8.7" "Perl Programmers Reference Guide"
.SH "NAME"
perltodo \- Perl TO\-DO List
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is a list of wishes for Perl.  Send updates to
\&\fIperl5\-porters@perl.org\fR.  If you want to work on any of these
projects, be sure to check the perl5\-porters archives for past ideas,
flames, and propaganda.  This will save you time and also prevent you
from implementing something that Larry has already vetoed.  One set
of archives may be found at:
.PP
.Vb 1
\&    http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/
.Ve
.SH "assertions"
.IX Header "assertions"
Clean up and finish support for assertions. See assertions.
.SH "iCOW"
.IX Header "iCOW"
Sarathy and Arthur have a proposal for an improved Copy On Write which
specifically will be able to \s-1COW\s0 new ithreads. If this can be implemented
it would be a good thing.
.SH "(?{...}) closures in regexps"
.IX Header "(?{...}) closures in regexps"
Fix (or rewrite) the implementation of the \f(CW\*(C`/(?{...})/\*(C'\fR closures.
.SH "A re-entrant regexp engine"
.IX Header "A re-entrant regexp engine"
This will allow the use of a regex from inside (?{ }), (??{ }) and
(?(?{ })|) constructs.
.SH "pragmata"
.IX Header "pragmata"
.Sh "lexical pragmas"
.IX Subsection "lexical pragmas"
Reimplement the mechanism of lexical pragmas to be more extensible. Fix
current pragmas that don't work well (or at all) with lexical scopes or in
run-time eval(\s-1STRING\s0) (\f(CW\*(C`sort\*(C'\fR, \f(CW\*(C`re\*(C'\fR, \f(CW\*(C`encoding\*(C'\fR for example). \s-1MJD\s0 has a
preliminary patch that implements this.
.Sh "use less 'memory'"
.IX Subsection "use less 'memory'"
Investigate trade offs to switch out perl's choices on memory usage.
Particularly perl should be able to give memory back.
.SH "prototypes and functions"
.IX Header "prototypes and functions"
.Sh "_ prototype character"
.IX Subsection "_ prototype character"
Study the possibility of adding a new prototype character, \f(CW\*(C`_\*(C'\fR, meaning
\&\*(L"this argument defaults to \f(CW$_\fR\*(R".
.Sh "inlining autoloaded constants"
.IX Subsection "inlining autoloaded constants"
Currently the optimiser can inline constants when expressed as subroutines
with prototype ($) that return a constant. Likewise, many packages wrapping
C libraries export lots of constants as subroutines which are AUTOLOADed on
demand. However, these have no prototypes, so can't be seen as constants by
the optimiser. Some way of cheaply (low syntax, low memory overhead) to the
perl compiler that a name is a constant would be great, so that it knows to
call the \s-1AUTOLOAD\s0 routine at compile time, and then inline the constant.
.Sh "Finish off lvalue functions"
.IX Subsection "Finish off lvalue functions"
The old perltodo notes \*(L"They don't work in the debugger, and they don't work for
list or hash slices.\*(R"
.SH "Unicode and UTF8"
.IX Header "Unicode and UTF8"
.Sh "Implicit Latin 1 => Unicode translation"
.IX Subsection "Implicit Latin 1 => Unicode translation"
Conversions from byte strings to \s-1UTF\-8\s0 currently map high bit characters
to Unicode without translation (or, depending on how you look at it, by
implicitly assuming that the byte strings are in Latin\-1). As perl assumes
the C locale by default, upgrading a string to \s-1UTF\-8\s0 may change the
meaning of its contents regarding character classes, case mapping, etc.
This should probably emit a warning (at least).
.Sh "\s-1UTF8\s0 caching code"
.IX Subsection "UTF8 caching code"
The string position/offset cache is not optional. It should be.
.Sh "Unicode in Filenames"
.IX Subsection "Unicode in Filenames"
chdir, chmod, chown, chroot, exec, glob, link, lstat, mkdir, open,
opendir, qx, readdir, readlink, rename, rmdir, stat, symlink, sysopen,
system, truncate, unlink, utime, \-X.  All these could potentially accept
Unicode filenames either as input or output (and in the case of system
and qx Unicode in general, as input or output to/from the shell).
Whether a filesystem \- an operating system pair understands Unicode in
filenames varies.
.PP
Known combinations that have some level of understanding include
Microsoft \s-1NTFS\s0, Apple \s-1HFS+\s0 (In Mac \s-1OS\s0 9 and X) and Apple \s-1UFS\s0 (in Mac
\&\s-1OS\s0 X), \s-1NFS\s0 v4 is rumored to be Unicode, and of course Plan 9.  How to
create Unicode filenames, what forms of Unicode are accepted and used
(\s-1UCS\-2\s0, \s-1UTF\-16\s0, \s-1UTF\-8\s0), what (if any) is the normalization form used,
and so on, varies.  Finding the right level of interfacing to Perl
requires some thought.  Remember that an \s-1OS\s0 does not implicate a
filesystem.
.PP
(The Windows \-C command flag \*(L"wide \s-1API\s0 support\*(R" has been at least
temporarily retired in 5.8.1, and the \-C has been repurposed, see
perlrun.)
.ie n .Sh "Unicode in %ENV"
.el .Sh "Unicode in \f(CW%ENV\fP"
.IX Subsection "Unicode in %ENV"
Currently the \f(CW%ENV\fR entries are always byte strings.
.SH "Regexps"
.IX Header "Regexps"
.Sh "regexp optimiser optional"
.IX Subsection "regexp optimiser optional"
The regexp optimiser is not optional. It should configurable to be, to allow
its performance to be measured, and its bugs to be easily demonstrated.
.SH "POD"
.IX Header "POD"
.Sh "\s-1POD\s0 \-> \s-1HTML\s0 conversion still sucks"
.IX Subsection "POD -> HTML conversion still sucks"
Which is crazy given just how simple \s-1POD\s0 purports to be, and how simple \s-1HTML\s0
can be.
.SH "Misc medium sized projects"
.IX Header "Misc medium sized projects"
.Sh "\s-1UNITCHECK\s0"
.IX Subsection "UNITCHECK"
Introduce a new special block, \s-1UNITCHECK\s0, which is run at the end of a
compilation unit (module, file, eval(\s-1STRING\s0) block). This will correspond to
the Perl 6 \s-1CHECK\s0. Perl 5's \s-1CHECK\s0 cannot be changed or removed because the
O.pm/B.pm backend framework depends on it.
.Sh "optional optimizer"
.IX Subsection "optional optimizer"
Make the peephole optimizer optional.
.Sh "You \s-1WANT\s0 *how* many"
.IX Subsection "You WANT *how* many"
Currently contexts are void, scalar and list. split has a special mechanism in
place to pass in the number of return values wanted. It would be useful to
have a general mechanism for this, backwards compatible and little speed hit.
This would allow proposals such as short circuiting sort to be implemented
as a module on \s-1CPAN\s0.
.Sh "lexical aliases"
.IX Subsection "lexical aliases"
Allow lexical aliases (maybe via the syntax \f(CW\*(C`my \e$alias = \e$foo\*(C'\fR.
.Sh "no 6"
.IX Subsection "no 6"
Make \f(CW\*(C`no 6\*(C'\fR and \f(CW\*(C`no v6\*(C'\fR work (opposite of \f(CW\*(C`use 5.005\*(C'\fR, etc.).
.Sh "IPv6"
.IX Subsection "IPv6"
Clean this up. Check everything in core works
.Sh "entersub \s-1XS\s0 vs Perl"
.IX Subsection "entersub XS vs Perl"
At the moment pp_entersub is huge, and has code to deal with entering both
perl and and \s-1XS\s0 subroutines. Subroutine implementations rarely change between 
perl and \s-1XS\s0 at run time, so investigate using 2 ops to enter subs (one for
\&\s-1XS\s0, one for perl) and swap between if a sub is redefined.
.Sh "@INC source filter to Filter::Simple"
.IX Subsection "@INC source filter to Filter::Simple"
The second return value from a sub in \f(CW@INC\fR can be a source filter. This isn't
documented. It should be changed to use Filter::Simple, tested and documented.
.Sh "bincompat functions"
.IX Subsection "bincompat functions"
There are lots of functions which are retained for binary compatibility.
Clean these up. Move them to mathom.c, and don't compile for blead?
.Sh "Use fchown/fchmod internally"
.IX Subsection "Use fchown/fchmod internally"
The old perltodo notes \*(L"This has been done in places, but needs a thorough
code review. Also fchdir is available in some platforms.\*(R"
.Sh "Constant folding"
.IX Subsection "Constant folding"
The peephole optimiser should trap errors during constant folding, and give
up on the folding, rather than bailing out at compile time.  It is quite
possible that the unfoldable constant is in unreachable code, eg something
akin to \f(CW\*(C`$a = 0/0 if 0;\*(C'\fR
.SH "Tests"
.IX Header "Tests"
.Sh "Make Schwern poorer"
.IX Subsection "Make Schwern poorer"
Tests for everything, At which point Schwern coughs up \f(CW$500\fR to \s-1TPF\s0.
.Sh "test B"
.IX Subsection "test B"
A test suite for the B module would be nice.
.Sh "common test code for timed bailout"
.IX Subsection "common test code for timed bailout"
Write portable self destruct code for tests to stop them burning \s-1CPU\s0 in
infinite loops. Needs to avoid using alarm, as some of the tests are testing
alarm/sleep or timers.
.SH "Installation"
.IX Header "Installation"
.Sh "compressed man pages"
.IX Subsection "compressed man pages"
Be able to install them
.Sh "Make Config.pm cope with differences between build and installed perl"
.IX Subsection "Make Config.pm cope with differences between build and installed perl"
.Sh "Relocatable perl"
.IX Subsection "Relocatable perl"
Make it possible to create a relocatable perl binary. Will need some collusion
with Config.pm. We could use a syntax of ... for location of current binary?
.Sh "make \s-1HTML\s0 install work"
.IX Subsection "make HTML install work"
And look at the splitting of perlfunc in chunks. It needs fixing.
.Sh "put patchlevel in \-v"
.IX Subsection "put patchlevel in -v"
Currently perl from p4/rsync ships with a patchlevel.h file that usually
defines one local patch, of the form \*(L"\s-1MAINT12345\s0\*(R" or \*(L"\s-1RC1\s0\*(R". The output of
perl \-v doesn't report that a perl isn't an official release, and this
information can get lost in bugs reports. Because of this, the minor version
isn't bumped up until \s-1RC\s0 time, to minimise the possibility of versions of perl
escaping that believe themselves to be newer than they actually are.
.PP
It would be useful to find an elegant way to have the \*(L"this is an interim
maintenance release\*(R" or \*(L"this is a release candidate\*(R" in the terse \-v output,
and have it so that it's easy for the pumpking to remove this just as the
release tarball is rolled up. This way the version pulled out of rsync would
always say \*(L"I'm a development release\*(R" and it would be safe to bump the
reported minor version as soon as a release ships, which would aid perl
developers.
.SH "Incremental things"
.IX Header "Incremental things"
Some tasks that don't need to get done in one big hit.
.Sh "autovivification"
.IX Subsection "autovivification"
Make all autovivification consistent w.r.t \s-1LVALUE/RVALUE\s0 and strict/no strict;
.Sh "fix tainting bugs"
.IX Subsection "fix tainting bugs"
Fix the bugs revealed by running the test suite with the \f(CW\*(C`\-t\*(C'\fR switch (via
\&\f(CW\*(C`make test.taintwarn\*(C'\fR).
.Sh "Make tainting consistent"
.IX Subsection "Make tainting consistent"
Tainting would be easier to use if it didn't take documented shortcuts and allow
taint to \*(L"leak\*(R" everywhere within an expression.
.Sh "Dual life everything"
.IX Subsection "Dual life everything"
As part of the \*(L"dists\*(R" plan, anything that doesn't belong in the smallest perl
distribution needs to be dual lifed. Anything else can be too.
.SH "Vague things"
.IX Header "Vague things"
Some more nebulous ideas
.Sh "threads"
.IX Subsection "threads"
Make threads more robust.
.Sh "\s-1POSIX\s0 memory footprint"
.IX Subsection "POSIX memory footprint"
Ilya observed that use \s-1POSIX\s0; eats memory like there's no tomorrow, and at
various times worked to cut it down. There is probably still fat to cut out \-
for example \s-1POSIX\s0 passes Exporter some very memory hungry data structures.
.ie n .Sh "Optimize away @_"
.el .Sh "Optimize away \f(CW@_\fP"
.IX Subsection "Optimize away @_"
The old perltodo notes \*(L"Look at the \*(R"reification" code in \f(CW\*(C`av.c\*(C'\fR".
.Sh "switch ops"
.IX Subsection "switch ops"
The old perltodo notes "Although we have \f(CW\*(C`Switch.pm\*(C'\fR in core, Larry points to
the dormant \f(CW\*(C`nswitch\*(C'\fR and \f(CW\*(C`cswitch\*(C'\fR ops in \fIpp.c\fR; using these opcodes would
be much faster."
.Sh "Attach/detach debugger from running program"
.IX Subsection "Attach/detach debugger from running program"
The old perltodo notes "With \f(CW\*(C`gdb\*(C'\fR, you can attach the debugger to a running
program if you pass the process \s-1ID\s0. It would be good to do this with the Perl
debugger on a running Perl program, although I'm not sure how it would be done."
ssh and screen do this with named pipes in tmp. Maybe we can too.
.Sh "A decent benchmark"
.IX Subsection "A decent benchmark"
perlbench seems impervious to any recent changes made to the perl core. It would
be useful to have a reasonable general benchmarking suite that roughly
represented what current perl programs do, and measurably reported whether
tweaks to the core improve, degrade or don't really affect performance, to
guide people attempting to optimise the guts of perl.
.Sh "readpipe(\s-1LIST\s0)"
.IX Subsection "readpipe(LIST)"
\&\fIsystem()\fR accepts a \s-1LIST\s0 syntax (and a \s-1PROGRAM\s0 \s-1LIST\s0 syntax) to avoid
running a shell. \fIreadpipe()\fR (the function behind qx//) could be similarly
extended.
.Sh "Self ties"
.IX Subsection "Self ties"
self ties are currently illegal because they caused too many segfaults. Maybe
the causes of these could be tracked down and self-ties on all types re\-
instated.
