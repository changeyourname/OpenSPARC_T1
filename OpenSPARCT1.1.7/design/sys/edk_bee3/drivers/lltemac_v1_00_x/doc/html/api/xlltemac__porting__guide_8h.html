<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
	Xilinx Driver lltemac v1_00_b: xlltemac_porting_guide.h File Reference
</title>
<link href="../../../../../../../doc/usenglish/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>xlltemac_porting_guide.h File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
This is a guide on how to move from using the temac driver for the plb_temac core to the lltemac driver for the xps_ll_temac core.<p>
<h2>Overview</h2>
<p>
The xps_ll_temac core is a bit different from previous ethernet IP provided in the EDK. The xps_ll_temac core provides no direct bus attachment, but rather expects data to come through a local link connection. An additional core needs to be connected this local link interface along with a connection to a bus that can be accessed by the processor.<p>
The EDK provides various such cores, xps_ll_fifo, and mpmc/sdma. The xps_ll_fifo core provides a fifo interface to the plbv46 bus and transfers data to the xps_ll_temac's local link interface. The dma cores transfer data directly out of memory into the local link interface.<p>
Because fifo and dma functionality is not included directly in the xps_ll_temac, the lltemac driver also does not have any routines to transfer data. Instead the lltemac driver relies upon a second driver that can control, for example, the xps_ll_fifo or dma cores.<p>
This guide will lay out the steps for porting your code from using the temac driver to the lltemac driver.<p>
There are 2 primary differences between the temac driver and the lltemac driver.<ol type=1>
<li>The Fifo and Dma functionality is outside of the lltemac driver.</li><li>Interrupt handling is performed outside of the lltemac driver.</li></ol>
<p>
<h2>Initialization</h2>
<p>
What used to be a single main operation to initialize the plb_temac driver, is now broken out into multiple steps. For a system with the xps_ll_temac core, the lltemac driver along with the driver for the core attached to the xps_ll_temac's local link interface must both be initialized.<p>
Here is an example of how a plb_temac instance might be initialized: <pre>
	XTemac_Config *TemacCfg;
	XTemac TemacInst;</pre><p>
<pre>	TemacCfg = XTemac_LookupConfig(XTEMAC_DEVICE_ID);
	XTemac_CfgInitialize(&amp;TemacInst, TemacCfg, TemacCfg-&gt;BaseAddress);
 </pre><p>
Here is an example of the lltemac method, utilizing the llfifo driver: <pre>
	<a class="el" href="struct_x_ll_temac___config.html">XLlTemac_Config</a> *TemacCfg;
	<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> TemacInst;
	XLlFifo FifoInst;</pre><p>
<pre>	TemacCfg = XLltemac_LookupConfig(XTEMAC_DEVICE_ID);
	XLlTemac_CfgInitialize(&amp;TemacInst, TemacCfg, TemacCfg-&gt;BaseAddress);</pre><p>
<pre>	if (<a class="el" href="xlltemac_8h.html#a35">XLlTemac_IsDma(&amp;TemacInst)</a>) {
		XLlDma_Initialize(&amp;FifoInst, TemacCfg-&gt;LLDevBaseAddress);
	} else {
		XLlFifo_Initialize(&amp;FifoInst, TemacCfg-&gt;LLDevBaseAddress);
 	}
 </pre><p>
<h2>Interrupt Handlers</h2>
<p>
The temac driver handled the temac interrupts and provided a way to register callback routines using the XTemac_SetHandler() routine. The lltemac driver does not handle interrupts. Instead the application or O/S driver must register its own interrupt handlers.<p>
Note that for data transfers, the application or O/S driver will want to handle the interrupts for the xps_ll_fifo or mpmc/sdma core and not use the tx or rx completion interrupts in the xps_ll_temac core. The xps_ll_temac rx and tx completion interrupts will trigger transfer completions at the wrong time, either before data has been transferred to the xps_ll_fifo or mpmc/smda core, or too late, after data has been transmitted out of the xps_ll_temac core when the driver only cares that the data is out of the xps_ll_fifo or mpmc/sdma core.<p>
The only interrupts from the xps_ll_temac core the application or O/S driver may care about are the fifo overflow, or rx reject interrupts. These are informational interrupts and no action is necessary to recover.<p>
Here is an example of how the application or O/S code might register a callback routine for dma receive: <pre>
	void DmaRecvHandler(void *ref) { ... }</pre><p>
<pre>	XTemac_SetHandler(&amp;TemacInst, XTE_HANDLER_SGRECV, DmaRecvHandler, ref);
 </pre><p>
For the lltemac driver the handler must be registered with the O/S or with the Xilinx interrupt driver, xintc: <pre>
	void DmaRecvHandler(XLlDma_BdRing *RxRingPtr) { ... }</pre><p>
<pre>	// EDK puts local link attached core interrupt id into lltemac config
	// Call the xintc driver to set up the interrupt handler.
	XIntc_Connect(&amp;IntcInst, TemacCfg-&gt;LLDmaRxIntr, (XinterruptHandler) DmaRecvHandler, RxRingPtr);
 </pre><p>
<h2>Transferring data using Fifo mode</h2>
<p>
The plb_temac's fifo mode supported filling the fifos with multiple packets before transmitting data. The xps_ll_fifo, that comes with the EDK version 9.2 or later, does not support this feature. If your existing code uses plb_temac to stuff the fifos, then your algorithm for writing to the fifos may have to be modified. Your existing code may transfer one frame at a time. If this is the case, then your algorithm will be fine, and just the routine calls will need to be modified.<p>
Note that the xps_ll_fifo core has internal buffer sizes fixed at 2K bytes, which prevents the use of jumbo frames in ethernet.<p>
Here is an example of how the temac driver might be used to write packets using fifo mode: <pre>
	// packet data in the variable, char *Frames[];
	// number of bytes in the frame in, int FrameSizes[];
	// number of frames in, int framesToSend;</pre><p>
<pre> 	ramesWritten = 0;
	for (index = 0; index &lt; framesToSend &amp;&amp;
			XTemac_FifoGetFreeBytes(&amp;TemacInst, XTE_SEND) &gt; FrameSizes[i];
 			index++) {
		XTemac_FifoWrite(&amp;TemacInst, Frame, FrameSizes[i], XTE_END+_OF_PACKET);
		FramesWritten++;
	}</pre><p>
<pre>	for (index = 0; index &lt; FramesWritten; index++) {
		XTemac_FifoSend(&amp;TemacInst, FrameSizes[i]);
	}</pre><p>
<pre>	// Poll for completion XTemac_FifoQuerySendStatus(), or rely on interrupt handler
 </pre><p>
For the llfifo driver the following would be used instead: <pre>
	// packet data in the variable, char *Frames[];
	// number of bytes in the frame in, int FrameSizes[];
	// number of frames in, int framesToSend;</pre><p>
<pre>	for (index = 0; index &lt; framesToSend; index++) {
		XLlFifo_Write(&amp;FifoInst, Frames[i], FrameSizes[i]);
		XLlFifo_TxSetLen(&amp;FifoInst, FrameSizes[i]);</pre><p>
<pre>		// Poll for completion XllFifo_Status(), or rely on interrupt handler
	}
 </pre><p>
<h2>Transferring data using Dma mode</h2>
<p>
The new dma driver for the MPMC/SDMA soft core works nearly the same as the driver use in the plb_temac. A few differences to note are:<ol type=1>
<li>The lldma driver operates on a ring data structure instead of using a Direction parameter on the routines.</li><li>The lldma driver supports buffer descriptors residing in cache. When the buffer descriptors reside in cache, the macros <code>XCACHE_INVALIDATE_DCACHE_RANGE</code>, and <code>XCACHE_FLUSH_DCACHE_RANGE</code> must be defined. Both of these macros take two parameters: a processor address and a length. Note that the O/S drivers provided by Xilinx for VxWorks and Linux already provide these macros in the xenv.h file.</li></ol>
<p>
See the lltemac and temac driver examples for more details.<p>
<h2>Routine Equivalence</h2>
<p>
Just about everything that could be done with the temac driver can be done in some way using a combination of drivers: lltemac, llfifo, lldma.<p>
The following is a list of routines in the temac driver and and the routines that would be used out of the lltemac, llfifo, lldma set instead.<p>
<table border="1" cellspacing="0" cellpadding="4">
<tr valing="top">
<td><small><b>plb_temac routine</b></small>  </td><td><small><b>replacement routine</b></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_CfgInitialize(Inst, Config, Virt)</code></small>  </td><td><small><code>XLltemac_CfgInitialize(Inst, Config, Virt)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_FifoGetFreeBytes(Inst, Direction)</code></small>  </td><td><small><code>XLlfifo_RxOccupancy(Inst) or XLlfifo_TxVacancy(Inst)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_FifoQueryRecvStatus(Inst)</code></small>  </td><td><small><code>XLlfifo_Status(Inst)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_FifoQuerySendStatus(Inst, StatusPtr)</code></small>  </td><td><small><code>*StatusPtr = XLlfifo_Status(Inst)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_FifoRead(Inst, Buf, Bytes, Eop)</code></small>  </td><td><small><code>XLlfifo_Read(Inst, Buf, Bytes)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_FifoRecv(Inst, BytesPtr)</code></small>  </td><td><small><code>*BytesPtr = XLlfifo_RxGetLen(Inst)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_FifoSend(Inst, Bytes)</code></small>  </td><td><small><code>XLlfifo_TxSetLen(Inst, Bytes)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_FifoWrite(Inst, Buf, Bytes, Eop)</code></small>  </td><td><small><code>XLlfifo_Write(Inst, Buf, Bytes)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_IntrFifoDisable(Inst, Direction)</code></small>  </td><td><small><code>XLlfifo_IntDisable(Inst, Mask)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_IntrFifoEnable(Inst, Direction)</code></small>  </td><td><small><code>XLlfifo_IntEnable(Inst, Mask)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_IntrSgCoalGet(Inst, Direction, ThreshPtr, TimerPtr)</code></small>  </td><td><small><code>XLldma_BdRingGetCoalesce(RingPtr, ThreshPtr, TimerPtr)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_IntrSgCoalSet(Inst, Direction, Thresh, Timer)</code></small>  </td><td><small><code>XLldma_BdRingSetCoalesce(RingPtr, Thresh, Timer)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_IntrSgDisable(Inst, Direction)</code></small>  </td><td><small><code>XLldma_mBdTringIntDisable(RingPtr, Mask)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_IntrSgEnable(Inst, Direction)</code></small>  </td><td><small><code>XLldma_mBdRingIntEnable(RingPtr, Mask)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_LookupConfig(id)</code></small>  </td><td><small><code>XLltemac_LookupConfig(id)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_mGetPhysicalInterface(Inst)</code></small>  </td><td><small><code>XLltemac_GetPhysicalInterface(Inst)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_mIsFifo(Inst)</code></small>  </td><td><small><code>XLltemac_IsFifo(Inst)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_mIsRecvFrame(Inst)</code></small>  </td><td><small><code>XLlfifo_RxOccupancy(Inst)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_mIsRecvFrameDropoped(Inst)</code></small>  </td><td><small><code>XLltemac_isRecvFrameDropped(Inst)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_mIsRxCsum(Inst)</code></small>  </td><td><small><code>XLltemac_IsRxCsum(Inst)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_mIsRxDre(Inst)</code></small>  </td><td><small><em>N/A</em></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_mIsSgDma(Inst)</code></small>  </td><td><small><code>XLltemac_IsDma(Inst)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_mIsStarted(Inst)</code></small>  </td><td><small><code>XLltemac_IsStarted(Inst)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_mIsTxCsum(Inst)</code></small>  </td><td><small><code>XLltemac_IsTxCsum(Inst)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_mSgSendBdCsumEnable(BdPtr)</code></small>  </td><td><small><code>XLldma_mBdWrite((BdPtr), XLldma_BD_STSCTRL_USR0_OFFSET (XLldma_mBdRead((BdPtr), XLldma_BD_STSCTRL_USR0_OFFSET)) | 1 )</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_mSgSendBdCsumDisable(BdPtr)</code></small>  </td><td><small><code>XLldma_mBdWrite((BdPtr), XLldma_BD_STSCTRL_USR0_OFFSET (XLldma_mBdRead((BdPtr), XLldma_BD_STSCTRL_USR0_OFFSET)) &amp; 0xFFFFFFFE)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_mSgSendBdCsumSetup(BdPtr, Start, Insert)</code></small>  </td><td><small><code>XLldma_mBdWrite((BdPtr), XLldma_BD_USR1_OFFSET, (Start) &lt;&lt; 16 | (Insert))</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_mSgSendBdCsumSeed(BdPtr, Seed)</code></small>  </td><td><small><code>XLldma_mBdWrite((BdPtr), XLldma_BD_USR2_OFFSET, Seed)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_mSgRecvBdCsumGet(BdPtr)</code></small>  </td><td><small><code>XLldma_mBdRead((BdPtr), XLldma_BD_USR3_OFFSET)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_mSgRecvBdNext(Inst, BdPtr)</code></small>  </td><td><small><code>XLldma_mBdRingNext(RingPtr, BdPtr)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_mSgRecvBdPrev(Inst, BdPtr)</code></small>  </td><td><small><code>XLldma_mBdRingPrev(RingPtr, BdPtr)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_mSgSendBdNext(Inst, BdPtr)</code></small>  </td><td><small><code>XLldma_mBdRingNext(RingPtr, BdPtr)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_mSgSendBdPrev(Inst, BdPtr)</code></small>  </td><td><small><code>XLldma_mBdRingPrev(RingPtr, BdPtr)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_Reset(Inst)</code></small>  </td><td><small><code>XLltemac_Reset(Inst)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_SelfTest(Inst)</code></small>  </td><td><small><em>N/A</em></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_SetHandler(...)</code></small>  </td><td><small><em>N/A</em></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_SetOptions(Inst, Options)</code></small>  </td><td><small><code>XLltemac_SetOptions(Inst, Options)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_SgAlloc(Inst, Direction, NumBd, BdPtr)</code></small>  </td><td><small><code>XLldma_BdRingAlloc(RingPtr, NumBd, BdPtr)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_SgCheck(Inst, Direction)</code></small>  </td><td><small><code>XLldma_BdRingCheck(RingPtr)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_SgCommit(Inst, Direction, NumBd, BdPtr)</code></small>  </td><td><small><code>XLldma_BdRingToHw(RingPtr, NumBd, BdPtr)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_SgFree(Inst, Direction, NumBd, BdPtr)</code></small>  </td><td><small><code>XLldma_BdRingFree(RingPtr, NumBd, BdPtr)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_SgGetProcessed(Inst, Direction, NumBd, BdPtr)</code></small>  </td><td><small><code>XLldma_BdRingFromHw(RingPtr, NumBd, BdPtr)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_SgSetSpace(Inst, Direction, PhysAddr, VirtAddr, Alignment, BdCount, BdTemplate)</code></small>  </td><td><small><code>XLldma_BdRingCreate(RingPtr, PhysAddr, VirtAddr, Alignment, BdCount), XLldma_BdRingClone(RingPtr, BdTemplate)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_SgUnAlloc(Inst, Direction, NumBd, BdPtr)</code></small>  </td><td><small><code>XLldma_BdRingUnAlloc(RingPtr, NumBd, BdPtr)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_Start(Inst)</code></small>  </td><td><small><code>XLltemac_Start(Inst)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_Stop(Inst)</code></small>  </td><td><small><code>XLltemac_Stop(Inst)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_SetOptions(Inst, Options)</code></small>  </td><td><small><code>XLltemac_SetOptions(Inst, Options)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_ClearOptions(Inst, Options)</code></small>  </td><td><small><code>XLltemac_ClearOptions(Inst, Options)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_GetOptions(Inst)</code></small>  </td><td><small><code>XLltemac_GetOptions(Inst)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_SetMacAddress(Inst, MacAddressPtr)</code></small>  </td><td><small><code>XLltemac_SetMacAddress(Inst, MacAddressPtr)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_GetMacAddress(Inst, MacAddressPtr)</code></small>  </td><td><small><code>XLltemac_GetMacAddress(Inst, MacAddressPtr)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_SetMaPauseAddress(Inst, AddressPtr)</code></small>  </td><td><small><code>XLltemac_SetMaPauseAddress(Inst, AddressPtr)lltemac</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_GetMaPauseAddress(Inst, AddressPtr)</code></small>  </td><td><small><code>XLltemac_GetMaPauseAddress(Inst, AddressPtr)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_SendPausePacket(Inst, PauseValue)</code></small>  </td><td><small><code>XLltemac_SendPausePacket(Inst, PauseValue)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_GetSgmiiStatus(Inst, SpeedPtr)</code></small>  </td><td><small><code> XLltemac_GetSgmiiStatus(Inst, SpeedPtr)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_GetRgmiiStatus(Inst, SpeedPtr, FullDuplexPtr, LinkupPtr)</code></small>  </td><td><small><code>XLltemac_GetRgmiiStatus(Inst, SpeedPtr, FullDuplexPtr, LinkupPtr)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_GetOperatingSpeed(Inst)</code></small>  </td><td><small><code>XLltemac_GetOperatingSpeed(Inst)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_SetOperatingSpeed(Inst, speed)</code></small>  </td><td><small><code>XLltemac_SetOperatingSpeed(Inst, speed)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_PhySetMdioDivisor(Inst, Divisor)</code></small>  </td><td><small><code>XLltemac_PhySetMdioDivisor(Inst, Divisor)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_PhyRead(Inst, PhyAddr, RegNum, DataPtr)</code></small>  </td><td><small><code>XLltemac_PhyRead(Inst, PhyAddr, RegNum, DataPtr)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_PhyWrite(Inst, PhyAddr, RegNum, Data)</code></small>  </td><td><small><code>XLltemac_PhyWrite(Inst, PhyAddr, RegNum, Data)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_MulticastAdd(Inst, AddressPtr, Entry)</code></small>  </td><td><small><code>XLltemac_MulticastAdd(Inst, AddressPtr, Entry)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_MulticastGet(Inst, AddressPtr, Entry)</code></small>  </td><td><small><code>XLltemac_MulticastGet(Inst, AddressPtr, Entry)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_MulticastClear(Inst, Entry)</code></small>  </td><td><small><code>XLltemac_MulticastAdd(Inst, Entry)</code></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_GetSoftStats(Inst, StatsPtr)</code></small>  </td><td><small><em>N/A</em></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_ClearSoftStats(Inst)</code></small>  </td><td><small><em>N/A</em></small>   </td></tr>
<tr valing="top">
<td><small><code>XTemac_SelfTest(Inst)</code></small>  </td><td><small><em>N/A</em></small>   </td></tr>
</table>
<p>
<h2>References</h2>
<p>
<ul>
<li>Linux 2.6 driver: &lt;<em>EDK_install</em>&gt;/sw/ThirdParty/bsp/linux_2_6_v1_00_b/drivers/lltemac_linux_2_6_v1_00_a/src/xlltemac_main.c</li><li>VxWorks 5.4 driver: &lt;<em>EDK_install</em>&gt;/sw/XilinxProcessorIPLib/drivers/lltemac_vxworks5_4_v1_00_a/src/xlltemac_end_adapter.c</li></ul>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
<p class="Copyright">
Copyright &copy; 1995-2008 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>

