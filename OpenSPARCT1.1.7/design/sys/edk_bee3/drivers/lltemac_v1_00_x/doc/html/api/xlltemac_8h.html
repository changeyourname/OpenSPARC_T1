<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
	Xilinx Driver lltemac v1_00_b: xlltemac.h File Reference
</title>
<link href="../../../../../../../doc/usenglish/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>xlltemac.h File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_ll_temac___config.html">XLlTemac_Config</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a></td></tr>

<tr><td colspan="2"><br><h2>Configuration options</h2></td></tr>
<tr><td colspan="2">The following are device configuration options. See the <em>XLlTemac_SetOptions</em>, <em>XLlTemac_ClearOptions</em> and <em>XLlTemac_GetOptions</em> routines for information on how to use options.<p>
The default state of the options are also noted below. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a3">XTE_PROMISC_OPTION</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a4">XTE_JUMBO_OPTION</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a5">XTE_VLAN_OPTION</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a6">XTE_FLOW_CONTROL_OPTION</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a7">XTE_FCS_STRIP_OPTION</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a8">XTE_FCS_INSERT_OPTION</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a9">XTE_LENTYPE_ERR_OPTION</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a10">XTE_TRANSMITTER_ENABLE_OPTION</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a11">XTE_RECEIVER_ENABLE_OPTION</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a12">XTE_BROADCAST_OPTION</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a13">XTE_MULTICAST_OPTION</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a14">XTE_DEFAULT_OPTIONS</a></td></tr>

<tr><td colspan="2"><br><h2>Reset parameters</h2></td></tr>
<tr><td colspan="2">These are used by function <a class="el" href="xlltemac_8c.html#a5">XLlTemac_Reset()</a>. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a15" doxytag="xlltemac.h::XTE_RESET_HARD"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>XTE_RESET_HARD</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a16" doxytag="xlltemac.h::XTE_NORESET_HARD"></a>
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>XTE_NORESET_HARD</b></td></tr>

<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a34">XLlTemac_IsStarted</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a35">XLlTemac_IsDma</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a36">XLlTemac_IsFifo</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a37">XLlTemac_LlDevBaseAddress</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a38">XLlTemac_IsRecvFrameDropped</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a39">XLlTemac_IsRxCsum</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a40">XLlTemac_IsTxCsum</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a41">XLlTemac_GetPhysicalInterface</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a42">XLlTemac_Status</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a43">XLlTemac_IntEnable</a>(InstancePtr, Mask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a44">XLlTemac_IntDisable</a>(InstancePtr, Mask)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a45">XLlTemac_IntPending</a>(InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a46">XLlTemac_IntClear</a>(InstancePtr, Mask)</td></tr>

<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="struct_x_ll_temac.html">XLlTemac</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a47">XLlTemac</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">XStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a48">XLlTemac_CfgInitialize</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, <a class="el" href="struct_x_ll_temac___config.html">XLlTemac_Config</a> *CfgPtr, u32 VirtualAddress)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a49">XLlTemac_Start</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a50">XLlTemac_Stop</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a51">XLlTemac_Reset</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, int HardCoreAction)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="struct_x_ll_temac___config.html">XLlTemac_Config</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a52">XLlTemac_LookupConfig</a> (u16 DeviceId)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">XStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a53">XLlTemac_SetOptions</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, u32 Options)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">XStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a54">XLlTemac_ClearOptions</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, u32 Options)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u32&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a55">XLlTemac_GetOptions</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">XStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a56">XLlTemac_SetMacAddress</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, void *AddressPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a57">XLlTemac_GetMacAddress</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, void *AddressPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">XStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a58">XLlTemac_SetMacPauseAddress</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, void *AddressPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a59">XLlTemac_GetMacPauseAddress</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, void *AddressPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">XStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a60">XLlTemac_SendPausePacket</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, u16 PauseValue)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">XStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a61">XLlTemac_GetSgmiiStatus</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, u16 *SpeedPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">XStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a62">XLlTemac_GetRgmiiStatus</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, u16 *SpeedPtr, int *IsFullDuplexPtr, int *IsLinkUpPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">u16&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a63">XLlTemac_GetOperatingSpeed</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a64">XLlTemac_SetOperatingSpeed</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, u16 Speed)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a65">XLlTemac_PhySetMdioDivisor</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, u8 Divisor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">XStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a68">XLlTemac_MulticastAdd</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, void *AddressPtr, int Entry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a69">XLlTemac_MulticastGet</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, void *AddressPtr, int Entry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">XStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac_8h.html#a70">XLlTemac_MulticastClear</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, int Entry)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="a41" doxytag="xlltemac.h::XLlTemac_GetPhysicalInterface"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XLlTemac_GetPhysicalInterface          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_GetPhysicalInterface returns the type of PHY interface being used by the given instance, specified by <em>InstancePtr</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XLlTemac_GetPhysicalInterface returns one of XTE_PHY_TYPE_&lt;x&gt; where &lt;x&gt; is MII, GMII, RGMII_1_3, RGMII_2_0, SGMII, or 1000BASE_X (defined in <a class="el" href="xlltemac_8h.html">xlltemac.h</a>).</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Signature: int <a class="el" href="xlltemac_8h.html#a41">XLlTemac_GetPhysicalInterface(XLlTemac *InstancePtr)</a>     </td>
  </tr>
</table>
<a class="anchor" name="a46" doxytag="xlltemac.h::XLlTemac_IntClear"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XLlTemac_IntClear          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr,         <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Mask&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_IntClear clears pending interrupts specified in <em>Mask</em>. The corresponding pending interrupt for each bit set to 1 in <em>Mask</em>, will be cleared. In other words, XLlTemac_IntClear uses the "set a bit to clear it" scheme.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>contains a bit mask of the pending interrupts to clear. The mask can be formed using a set of bitwise or'd values from the <code>XTE_INT_*_MASK</code> preprocessor symbols.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xlltemac_8h.html#a46">XLlTemac_IntClear(XLlTemac *InstancePtr, u32 Mask)</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a44" doxytag="xlltemac.h::XLlTemac_IntDisable"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XLlTemac_IntDisable          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr,         <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Mask&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_IntDisable disables the interrupts specified in <em>Mask</em>. The corresponding interrupt for each bit set to 1 in <em>Mask</em>, will be disabled. In other words, XLlTemac_IntDisable uses the "set a bit to clear it" scheme.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>contains a bit mask of the interrupts to disable. The mask can be formed using a set of bitwise or'd values from the <code>XTE_INT_*_MASK</code> preprocessor symbols.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>N/A</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xlltemac_8h.html#a44">XLlTemac_IntDisable(XLlTemac *InstancePtr, u32 Mask)</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a43" doxytag="xlltemac.h::XLlTemac_IntEnable"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XLlTemac_IntEnable          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr,         <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>Mask&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_IntEnable enables the interrupts specified in <em>Mask</em>. The corresponding interrupt for each bit set to 1 in <em>Mask</em>, will be enabled.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Mask</em>&nbsp;</td><td>contains a bit mask of the interrupts to enable. The mask can be formed using a set of bitwise or'd values from the <code>XTE_INT_*_MASK</code> preprocessor symbols.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>N/A</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: void <a class="el" href="xlltemac_8h.html#a43">XLlTemac_IntEnable(XLlTemac *InstancePtr, u32 Mask)</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a45" doxytag="xlltemac.h::XLlTemac_IntPending"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XLlTemac_IntPending          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_IntPending returns a bit mask of the pending interrupts. Each bit set to 1 in the return value represents a pending interrupt.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XLlTemac_IntPending returns a bit mask of the interrupts that are pending. The mask will be a set of bitwise or'd values from the <code>XTE_INT_*_MASK</code> preprocessor symbols.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 <a class="el" href="xlltemac_8h.html#a45">XLlTemac_IntPending(XLlTemac *InstancePtr)</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a35" doxytag="xlltemac.h::XLlTemac_IsDma"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XLlTemac_IsDma          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_IsDma reports if the device is currently connected to DMA.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XLlTemac_IsDma returns XTRUE if the device is connected DMA. Otherwise, XLlTemac_IsDma returns XFALSE.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Signature: u32 <a class="el" href="xlltemac_8h.html#a35">XLlTemac_IsDma(XLlTemac *InstancePtr)</a>     </td>
  </tr>
</table>
<a class="anchor" name="a36" doxytag="xlltemac.h::XLlTemac_IsFifo"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XLlTemac_IsFifo          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_IsFifo reports if the device is currently connected to a fifo core.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XLlTemac_IsFifo returns XTRUE if the device is connected to a fifo core. Otherwise, XLlTemac_IsFifo returns XFALSE.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Signature: u32 <a class="el" href="xlltemac_8h.html#a36">XLlTemac_IsFifo(XLlTemac *InstancePtr)</a>     </td>
  </tr>
</table>
<a class="anchor" name="a38" doxytag="xlltemac.h::XLlTemac_IsRecvFrameDropped"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XLlTemac_IsRecvFrameDropped          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_IsRecvFrameDropped determines if the device thinks it has dropped a receive frame.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XLlTemac_IsRecvFrameDropped returns TRUE if the device interrupt status register reports that a frame has been dropped. Otherwise, XLlTemac_IsRecvFrameDropped returns FALSE.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Signature: u32 <a class="el" href="xlltemac_8h.html#a38">XLlTemac_IsRecvFrameDropped(XLlTemac *InstancePtr)</a>     </td>
  </tr>
</table>
<a class="anchor" name="a39" doxytag="xlltemac.h::XLlTemac_IsRxCsum"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XLlTemac_IsRxCsum          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_IsRxCsum determines if the device is configured with checksum offloading on the receive channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XLlTemac_IsRxCsum returns TRUE if the device is configured with checksum offloading on the receive channel. Otherwise, XLlTemac_IsRxCsum returns FALSE.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Signature: u32 <a class="el" href="xlltemac_8h.html#a39">XLlTemac_IsRxCsum(XLlTemac *InstancePtr)</a>     </td>
  </tr>
</table>
<a class="anchor" name="a34" doxytag="xlltemac.h::XLlTemac_IsStarted"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XLlTemac_IsStarted          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_IsStarted reports if the device is in the started or stopped state. To be in the started state, the calling code must have made a successful call to <em>XLlTemac_Start</em>. To be in the stopped state, <em>XLlTemac_Stop</em> or <em>XLlTemac_CfgInitialize</em> function must have been called.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XLlTemac_IsStarted returns TRUE if the device has been started. Otherwise, XLlTemac_IsStarted returns FALSE.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Signature: u32 <a class="el" href="xlltemac_8h.html#a34">XLlTemac_IsStarted(XLlTemac *InstancePtr)</a>     </td>
  </tr>
</table>
<a class="anchor" name="a40" doxytag="xlltemac.h::XLlTemac_IsTxCsum"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XLlTemac_IsTxCsum          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_IsTxCsum determines if the device is configured with checksum offloading on the transmit channel.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XLlTemac_IsTxCsum returns TRUE if the device is configured with checksum offloading on the transmit channel. Otherwise, XLlTemac_IsTxCsum returns FALSE.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Signature: u32 <a class="el" href="xlltemac_8h.html#a40">XLlTemac_IsTxCsum(XLlTemac *InstancePtr)</a>     </td>
  </tr>
</table>
<a class="anchor" name="a37" doxytag="xlltemac.h::XLlTemac_LlDevBaseAddress"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XLlTemac_LlDevBaseAddress          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_LlDevBaseAddress reports the base address of the core connected to the TEMAC's local link interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XLlTemac_IsFifo returns the base address of the core connected to the TEMAC's local link interface.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Signature: u32 <a class="el" href="xlltemac_8h.html#a37">XLlTemac_LlDevBaseAddress(XLlTemac *InstancePtr)</a>     </td>
  </tr>
</table>
<a class="anchor" name="a42" doxytag="xlltemac.h::XLlTemac_Status"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XLlTemac_Status          </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">InstancePtr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_Status returns a bit mask of the interrupt status register (ISR). XLlTemac_Status can be used to query the status without having to have interrupts enabled.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XLlTemac_IntStatus returns a bit mask of the status conditions. The mask will be a set of bitwise or'd values from the <code>XTE_INT_*_MASK</code> preprocessor symbols.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>C-style signature: u32 XLlTemac_IntStatus(XLlTemac *InstancePtr) </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a12" doxytag="xlltemac.h::XTE_BROADCAST_OPTION"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XTE_BROADCAST_OPTION          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XTE_BROADCAST_OPTION specifies the TEMAC channel to receive frames sent to the broadcast Ethernet address. This driver sets this option to enabled (set) by default.     </td>
  </tr>
</table>
<a class="anchor" name="a14" doxytag="xlltemac.h::XTE_DEFAULT_OPTIONS"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XTE_DEFAULT_OPTIONS          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XTE_DEFAULT_OPTIONS specify the options set in <a class="el" href="xlltemac_8c.html#a5">XLlTemac_Reset()</a> and <a class="el" href="xlltemac_8c.html#a2">XLlTemac_CfgInitialize()</a>     </td>
  </tr>
</table>
<a class="anchor" name="a8" doxytag="xlltemac.h::XTE_FCS_INSERT_OPTION"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XTE_FCS_INSERT_OPTION          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XTE_FCS_INSERT_OPTION specifies the TEMAC channel to generate the FCS field and add PAD automatically for outgoing frames. This driver sets this option to enabled (set) by default.     </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="xlltemac.h::XTE_FCS_STRIP_OPTION"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XTE_FCS_STRIP_OPTION          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XTE_FCS_STRIP_OPTION specifies the TEMAC channel to strip FCS and PAD from received frames. Note that PAD from VLAN frames is not stripped. This driver sets this option to enabled (set) by default.     </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="xlltemac.h::XTE_FLOW_CONTROL_OPTION"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XTE_FLOW_CONTROL_OPTION          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XTE_FLOW_CONTROL_OPTION specifies the TEMAC channel to recognize received flow control frames. This driver sets this option to enabled (set) by default.     </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="xlltemac.h::XTE_JUMBO_OPTION"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XTE_JUMBO_OPTION          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XTE_JUMBO_OPTION specifies the TEMAC channel to accept jumbo frames for transmit and receive. This driver sets this option to disabled (cleared) by default.     </td>
  </tr>
</table>
<a class="anchor" name="a9" doxytag="xlltemac.h::XTE_LENTYPE_ERR_OPTION"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XTE_LENTYPE_ERR_OPTION          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XTE_LENTYPE_ERR_OPTION specifies the TEMAC channel to enable Length/Type error checking (mismatched type/length field) for received frames. This driver sets this option to enabled (set) by default.     </td>
  </tr>
</table>
<a class="anchor" name="a13" doxytag="xlltemac.h::XTE_MULTICAST_OPTION"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XTE_MULTICAST_OPTION          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XTE_MULTICAST_OPTION specifies the TEMAC channel to receive frames sent to Ethernet addresses that are programmed into the Multicast Address Table (MAT). This driver sets this option to disabled (cleared) by default.     </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="xlltemac.h::XTE_PROMISC_OPTION"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XTE_PROMISC_OPTION          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XTE_PROMISC_OPTION specifies the TEMAC channel to accept all incoming packets. This driver sets this option to disabled (cleared) by default.     </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="xlltemac.h::XTE_RECEIVER_ENABLE_OPTION"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XTE_RECEIVER_ENABLE_OPTION          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XTE_RECEIVER_ENABLE_OPTION specifies the TEMAC channel receiver to be enabled. This driver sets this option to enabled (set) by default.     </td>
  </tr>
</table>
<a class="anchor" name="a10" doxytag="xlltemac.h::XTE_TRANSMITTER_ENABLE_OPTION"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XTE_TRANSMITTER_ENABLE_OPTION          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XTE_TRANSMITTER_ENABLE_OPTION specifies the TEMAC channel transmitter to be enabled. This driver sets this option to enabled (set) by default.     </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="xlltemac.h::XTE_VLAN_OPTION"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">#define XTE_VLAN_OPTION          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XTE_VLAN_OPTION specifies the TEMAC channel to enable VLAN support for transmit and receive. This driver sets this option to disabled (cleared) by default.     </td>
  </tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="a47" doxytag="xlltemac.h::XLlTemac"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef struct <a class="el" href="struct_x_ll_temac.html">XLlTemac</a>  <a class="el" href="struct_x_ll_temac.html">XLlTemac</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
struct <a class="el" href="struct_x_ll_temac.html">XLlTemac</a> is the type for TEMAC driver instance data. The calling code is required to use a unique instance of this structure for every TEMAC channel used in the system. Each channel is treated as a separate device from the point of view of this driver. A reference to a structure of this type is then passed to the driver API functions.     </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a48" doxytag="xlltemac.h::XLlTemac_CfgInitialize"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">XStatus XLlTemac_CfgInitialize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="struct_x_ll_temac___config.html">XLlTemac_Config</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>CfgPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>EffectiveAddress</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_CfgInitialize initializes a TEMAC channel along with the <em>InstancePtr</em> that references it. Each TEMAC channel is treated as a separate device from the point of view of this driver.<p>
The PHY is setup independently from the TEMAC. Use the MII or whatever other interface may be present for setup.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the memory instance to be associated with the TEMAC channel upon initialization. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>CfgPtr</em>&nbsp;</td><td>references the structure holding the hardware configuration for the TEMAC channel to initialize. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EffectiveAddress</em>&nbsp;</td><td>is the processor address used to access the base address of the TEMAC channel. In systems with an MMU and virtual memory, <em>EffectiveAddress</em> is the virtual address mapped to the physical in <code>ConfigPtr-&gt;Config.BaseAddress</code>. In systems without an active MMU, <em>EffectiveAddress</em> should be set to the same value as <code>ConfigPtr-&gt;Config.BaseAddress</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XLlTemac_CfgInitialize returns XST_SUCCESS.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a54" doxytag="xlltemac.h::XLlTemac_ClearOptions"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">XStatus XLlTemac_ClearOptions           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Options</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_ClearOptions clears the options, <em>Options</em> for the TEMAC channel, specified by <em>InstancePtr</em>. The TEMAC channel should be stopped with <a class="el" href="xlltemac_8c.html#a4">XLlTemac_Stop()</a> before changing options.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Options</em>&nbsp;</td><td>is a bitmask of OR'd XTE_*_OPTION values for options to clear. Options not specified are not affected.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On successful completion, XLlTemac_ClearOptions returns XST_SUCCESS. Otherwise, if the device has not been stopped, XLlTemac_ClearOptions returns XST_DEVICE_IS_STARTED.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>See <a class="el" href="xlltemac_8h.html">xlltemac.h</a> for a description of the available options.</dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a57" doxytag="xlltemac.h::XLlTemac_GetMacAddress"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XLlTemac_GetMacAddress           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>AddressPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_GetMacAddress gets the MAC address for the TEMAC channel, specified by <em>InstancePtr</em> into the memory buffer specified by <em>AddressPtr</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>references the memory buffer to store the retrieved MAC address. This memory buffer must be at least 6 bytes in length.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>N/A</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a59" doxytag="xlltemac.h::XLlTemac_GetMacPauseAddress"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XLlTemac_GetMacPauseAddress           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>AddressPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_GetMacPauseAddress gets the MAC address used for pause frames for the TEMAC channel specified by <em>InstancePtr</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>references the memory buffer to store the retrieved MAC address. This memory buffer must be at least 6 bytes in length.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>N/A</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a63" doxytag="xlltemac.h::XLlTemac_GetOperatingSpeed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u16 XLlTemac_GetOperatingSpeed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_GetOperatingSpeed gets the current operating link speed. This may be the value set by <a class="el" href="xlltemac_8c.html#a12">XLlTemac_SetOperatingSpeed()</a> or a hardware default.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XLlTemac_GetOperatingSpeed returns the link speed in units of megabits per second.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a55" doxytag="xlltemac.h::XLlTemac_GetOptions"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">u32 XLlTemac_GetOptions           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_GetOptions returns the current option settings.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XLlTemac_GetOptions returns a bitmask of XTE_*_OPTION constants, each bit specifying an option that is currently active.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>See <a class="el" href="xlltemac_8h.html">xlltemac.h</a> for a description of the available options. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a62" doxytag="xlltemac.h::XLlTemac_GetRgmiiStatus"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">XStatus XLlTemac_GetRgmiiStatus           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u16 *&nbsp;</td>
          <td class="mdname" nowrap> <em>SpeedPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>IsFullDuplexPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>IsLinkUpPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_GetRgmiiStatus get the state of the link when using the RGMII media interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SpeedPtr</em>&nbsp;</td><td>references the location to store the result, which is the autonegotiaged link speed in units of Mbits/sec, either 0, 10, 100, or 1000. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IsFullDuplexPtr</em>&nbsp;</td><td>references the value to set to indicate full duplex operation. XLlTemac_GetRgmiiStatus sets <em>IsFullDuplexPtr</em> to TRUE when the RGMII link is operating in full duplex mode. Otherwise, XLlTemac_GetRgmiiStatus sets <em>IsFullDuplexPtr</em> to FALSE. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IsLinkUpPtr</em>&nbsp;</td><td>references the value to set to indicate the link status. XLlTemac_GetRgmiiStatus sets <em>IsLinkUpPtr</em> to TRUE when the RGMII link up. Otherwise, XLlTemac_GetRgmiiStatus sets <em>IsLinkUpPtr</em> to FALSE.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On successful completion, XLlTemac_GetRgmiiStatus returns XST_SUCCESS. Otherwise, if TEMAC channel is not using an RGMII interface, XLlTemac_GetRgmiiStatus returns XST_NO_FEATURE.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a61" doxytag="xlltemac.h::XLlTemac_GetSgmiiStatus"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">XStatus XLlTemac_GetSgmiiStatus           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u16 *&nbsp;</td>
          <td class="mdname" nowrap> <em>SpeedPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_GetSgmiiStatus get the state of the link when using the SGMII media interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SpeedPtr</em>&nbsp;</td><td>references the location to store the result, which is the autonegotiated link speed in units of Mbits/sec, either 0, 10, 100, or 1000.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On successful completion, XLlTemac_GetSgmiiStatus returns XST_SUCCESS. Otherwise, if TEMAC channel is not using an SGMII interface, XLlTemac_GetSgmiiStatus returns XST_NO_FEATURE.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a52" doxytag="xlltemac.h::XLlTemac_LookupConfig"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac___config.html">XLlTemac_Config</a>* XLlTemac_LookupConfig           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">u16&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>DeviceId</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_LookupConfig returns a reference to an <a class="el" href="struct_x_ll_temac___config.html">XLlTemac_Config</a> structure based on the unique device id, <em>DeviceId</em>. The return value will refer to an entry in the device configuration table defined in the xlltemac_g.c file.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>DeviceId</em>&nbsp;</td><td>is the unique device ID of the device for the lookup operation.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>XLlTemac_LookupConfig returns a reference to a config record in the configuration table (in xlltemac_g.c) corresponding to <em>DeviceId</em>, or NULL if no match is found. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="a68" doxytag="xlltemac.h::XLlTemac_MulticastAdd"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">XStatus XLlTemac_MulticastAdd           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>AddressPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Entry</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
in the TEMAC channel's multicast filter list.<p>
XLlTemac_MulticastAdd adds the Ethernet address, <em>AddressPtr</em> to the TEMAC channel's multicast filter list, at list index <em>Entry</em>. The address referenced by <em>AddressPtr</em> may be of any unicast, multicast, or broadcast address form. The harware for the TEMAC channel can hold up to XTE_MULTI_MAT_ENTRIES addresses in this filter list.<br>
<br>
<p>
The device must be stopped to use this function.<br>
<br>
<p>
Once an Ethernet address is programmed, the TEMAC channel will begin receiving data sent from that address. The TEMAC hardware does not have a control bit to disable multicast filtering. The only way to prevent the TEMAC channel from receiving messages from an Ethernet address in the Multicast Address Table (MAT) is to clear it with <a class="el" href="xlltemac_8h.html#a70">XLlTemac_MulticastClear()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is a pointer to the 6-byte Ethernet address to set. The previous address at the location <em>Entry</em> (if any) is overwritten with the value at <em>AddressPtr</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Entry</em>&nbsp;</td><td>is the hardware storage location to program this address and must be between 0..XTE_MULTI_MAT_ENTRIES-1.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On successful completion, XLlTemac_MulticastAdd returns XST_SUCCESS. Otherwise, if the TEMAC channel is not stopped, XLlTemac_MulticastAdd returns XST_DEVICE_IS_STARTED.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a70" doxytag="xlltemac.h::XLlTemac_MulticastClear"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">XStatus XLlTemac_MulticastClear           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Entry</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_MulticastClear clears the Ethernet address stored at index <em>Entry</em> in the TEMAC channel's multicast filter list.<br>
<br>
<p>
The device must be stopped to use this function.<br>
<br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Entry</em>&nbsp;</td><td>is the HW storage location used when this address was added. It must be between 0..XTE_MULTI_MAT_ENTRIES-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Entry</em>&nbsp;</td><td>is the hardware storage location to clear and must be between 0..XTE_MULTI_MAT_ENTRIES-1.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On successful completion, XLlTemac_MulticastClear returns XST_SUCCESS. Otherwise, if the TEMAC channel is not stopped, XLlTemac_MulticastClear returns XST_DEVICE_IS_STARTED.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a69" doxytag="xlltemac.h::XLlTemac_MulticastGet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XLlTemac_MulticastGet           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>AddressPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Entry</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_MulticastGet gets the Ethernet address stored at index <em>Entry</em> in the TEMAC channel's multicast filter list.<br>
<br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>references the memory buffer to store the retrieved Ethernet address. This memory buffer must be at least 6 bytes in length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Entry</em>&nbsp;</td><td>is the hardware storage location from which to retrieve the address and must be between 0..XTE_MULTI_MAT_ENTRIES-1.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>N/A</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a65" doxytag="xlltemac.h::XLlTemac_PhySetMdioDivisor"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XLlTemac_PhySetMdioDivisor           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u8&nbsp;</td>
          <td class="mdname" nowrap> <em>Divisor</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_PhySetMdioDivisor sets the MDIO clock divisor in the TEMAC channel, specified by <em>InstancePtr</em> to the value, <em>Divisor</em>. This function must be called once after each reset prior to accessing MII PHY registers.<p>
From the Virtex-4 Embedded Tri-Mode Ethernet MAC User's Guide, the following equation governs the MDIO clock to the PHY:<p>
<pre>
              f[HOSTCLK]
   f[MDC] = -----------------
            (1 + Divisor) * 2
 </pre><p>
where f[HOSTCLK] is the bus clock frequency in MHz, and f[MDC] is the MDIO clock frequency in MHz to the PHY. Typically, f[MDC] should not exceed 2.5 MHz. Some PHYs can tolerate faster speeds which means faster access.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Divisor</em>&nbsp;</td><td>is the divisor value to set within the range of 0 to XTE_MC_CLK_DVD_MAX.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a51" doxytag="xlltemac.h::XLlTemac_Reset"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XLlTemac_Reset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>HardCoreAction</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_Reset performs a reset of the TEMAC channel, specified by <em>InstancePtr</em>, or both channels if <em>HardCoreAction</em> is set to XTE_RESET_HARD.<p>
XLlTemac_Reset also resets the TEMAC channel's options to their default values.<p>
The calling software is responsible for re-configuring the TEMAC channel (if necessary) and restarting the MAC after the reset.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>HardCoreAction</em>&nbsp;</td><td>describes how XLlTemac_Reset should treat the hard core block of the TEMAC.<br>
<br>
</td></tr>
  </table>
</dl>
If XTE_RESET_HARD is set to XTE_RESET_HARD, then XLlTemac_Reset asserts the reset signal to the hard core block which will reset both channels of the TEMAC. This, of course, will bork any activity that may be occuring on the other channel. So, be careful here.<br>
<br>
<p>
Otherwise, XLlTemac_Reset resets just the transmitter and receiver of this TEMAC channel.<p>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a60" doxytag="xlltemac.h::XLlTemac_SendPausePacket"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">XStatus XLlTemac_SendPausePacket           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u16&nbsp;</td>
          <td class="mdname" nowrap> <em>PauseValue</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_SendPausePacket sends a pause packet with the value of <em>PauseValue</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PauseValue</em>&nbsp;</td><td>is the pause value in units of 512 bit times.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On successful completion, XLlTemac_SendPausePacket returns XST_SUCCESS. Otherwise, if the TEMAC channel is not started, XLlTemac_SendPausePacket returns XST_DEVICE_IS_STOPPED.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a56" doxytag="xlltemac.h::XLlTemac_SetMacAddress"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">XStatus XLlTemac_SetMacAddress           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>AddressPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_SetMacAddress sets the MAC address for the TEMAC channel, specified by <em>InstancePtr</em> to the MAC address specified by <em>AddressPtr</em>. The TEMAC channel must be stopped before calling this function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is a reference to the 6-byte MAC address to set.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On successful completion, XLlTemac_SetMacAddress returns XST_SUCCESS. Otherwise, if the TEMAC channel has not stopped, XLlTemac_SetMacAddress returns XST_DEVICE_IS_STARTED.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a58" doxytag="xlltemac.h::XLlTemac_SetMacPauseAddress"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">XStatus XLlTemac_SetMacPauseAddress           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>AddressPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_SetMacPauseAddress sets the MAC address used for pause frames to <em>AddressPtr</em>. <em>AddressPtr</em> will be the address the TEMAC channel will recognize as being for pause frames. Pause frames transmitted with <a class="el" href="xlltemac_8h.html#a60">XLlTemac_SendPausePacket()</a> will also use this address.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is a pointer to the 6-byte Ethernet address to set.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On successful completion, XLlTemac_SetMacPauseAddress returns XST_SUCCESS. Otherwise, if the TEMAC channel is not stopped, XLlTemac_SetMacPauseAddress returns XST_DEVICE_IS_STARTED.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a64" doxytag="xlltemac.h::XLlTemac_SetOperatingSpeed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XLlTemac_SetOperatingSpeed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u16&nbsp;</td>
          <td class="mdname" nowrap> <em>Speed</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_SetOperatingSpeed sets the current operating link speed. For any traffic to be passed, this speed must match the current MII/GMII/SGMII/RGMII link speed.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Speed</em>&nbsp;</td><td>is the speed to set in units of Mbps. Valid values are 10, 100, or 1000. XLlTemac_SetOperatingSpeed ignores invalid values.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a53" doxytag="xlltemac.h::XLlTemac_SetOptions"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">XStatus XLlTemac_SetOptions           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u32&nbsp;</td>
          <td class="mdname" nowrap> <em>Options</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_SetOptions enables the options, <em>Options</em> for the TEMAC channel, specified by <em>InstancePtr</em>. The TEMAC channel should be stopped with <a class="el" href="xlltemac_8c.html#a4">XLlTemac_Stop()</a> before changing options.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Options</em>&nbsp;</td><td>is a bitmask of OR'd XTE_*_OPTION values for options to set. Options not specified are not affected.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On successful completion, XLlTemac_SetOptions returns XST_SUCCESS. Otherwise, if the device has not been stopped, XLlTemac_SetOptions returns XST_DEVICE_IS_STARTED.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>See <a class="el" href="xlltemac_8h.html">xlltemac.h</a> for a description of the available options.</dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a49" doxytag="xlltemac.h::XLlTemac_Start"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XLlTemac_Start           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_Start starts the TEMAC channel as follows:<ul>
<li>Enable transmitter if XTE_TRANSMIT_ENABLE_OPTION is set</li><li>Enable receiver if XTE_RECEIVER_ENABLE_OPTION is set</li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>N/A</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a50" doxytag="xlltemac.h::XLlTemac_Stop"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XLlTemac_Stop           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>InstancePtr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_Stop gracefully stops the TEMAC channel as follows:<ul>
<li>Disable all interrupts from this device</li><li>Disable the receiver</li></ul>
<p>
XLlTemac_Stop does not modify any of the current device options.<p>
Since the transmitter is not disabled, frames currently in internal buffers or in process by a DMA engine are allowed to be transmitted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>N/A</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<p class="Copyright">
Copyright &copy; 1995-2008 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>

