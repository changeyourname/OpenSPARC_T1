<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
	Xilinx Driver lltemac v1_00_b: xlltemac_control.c File Reference
</title>
<link href="../../../../../../../doc/usenglish/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>xlltemac_control.c File Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Functions in this file implement general purpose command and control related functionality. See <a class="el" href="xlltemac_8h.html">xlltemac.h</a> for a detailed description of the driver.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -------------------------------------------------------
 1.00a jvb  11/10/06 First release
 </pre>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">XStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac__control_8c.html#a0">XLlTemac_MulticastAdd</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, void *AddressPtr, int Entry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac__control_8c.html#a1">XLlTemac_MulticastGet</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, void *AddressPtr, int Entry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">XStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac__control_8c.html#a2">XLlTemac_MulticastClear</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, int Entry)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">XStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac__control_8c.html#a3">XLlTemac_SetMacPauseAddress</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, void *AddressPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac__control_8c.html#a4">XLlTemac_GetMacPauseAddress</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, void *AddressPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">XStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac__control_8c.html#a5">XLlTemac_SendPausePacket</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, u16 PauseValue)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">XStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac__control_8c.html#a6">XLlTemac_GetSgmiiStatus</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, u16 *SpeedPtr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">XStatus&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="xlltemac__control_8c.html#a7">XLlTemac_GetRgmiiStatus</a> (<a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *InstancePtr, u16 *SpeedPtr, int *IsFullDuplexPtr, int *IsLinkUpPtr)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="a4" doxytag="xlltemac_control.c::XLlTemac_GetMacPauseAddress"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XLlTemac_GetMacPauseAddress           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>AddressPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_GetMacPauseAddress gets the MAC address used for pause frames for the TEMAC channel specified by <em>InstancePtr</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>references the memory buffer to store the retrieved MAC address. This memory buffer must be at least 6 bytes in length.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>N/A</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a7" doxytag="xlltemac_control.c::XLlTemac_GetRgmiiStatus"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">XStatus XLlTemac_GetRgmiiStatus           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u16 *&nbsp;</td>
          <td class="mdname" nowrap> <em>SpeedPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>IsFullDuplexPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int *&nbsp;</td>
          <td class="mdname" nowrap> <em>IsLinkUpPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_GetRgmiiStatus get the state of the link when using the RGMII media interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SpeedPtr</em>&nbsp;</td><td>references the location to store the result, which is the autonegotiaged link speed in units of Mbits/sec, either 0, 10, 100, or 1000. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IsFullDuplexPtr</em>&nbsp;</td><td>references the value to set to indicate full duplex operation. XLlTemac_GetRgmiiStatus sets <em>IsFullDuplexPtr</em> to TRUE when the RGMII link is operating in full duplex mode. Otherwise, XLlTemac_GetRgmiiStatus sets <em>IsFullDuplexPtr</em> to FALSE. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>IsLinkUpPtr</em>&nbsp;</td><td>references the value to set to indicate the link status. XLlTemac_GetRgmiiStatus sets <em>IsLinkUpPtr</em> to TRUE when the RGMII link up. Otherwise, XLlTemac_GetRgmiiStatus sets <em>IsLinkUpPtr</em> to FALSE.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On successful completion, XLlTemac_GetRgmiiStatus returns XST_SUCCESS. Otherwise, if TEMAC channel is not using an RGMII interface, XLlTemac_GetRgmiiStatus returns XST_NO_FEATURE.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a6" doxytag="xlltemac_control.c::XLlTemac_GetSgmiiStatus"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">XStatus XLlTemac_GetSgmiiStatus           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u16 *&nbsp;</td>
          <td class="mdname" nowrap> <em>SpeedPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_GetSgmiiStatus get the state of the link when using the SGMII media interface.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>SpeedPtr</em>&nbsp;</td><td>references the location to store the result, which is the autonegotiated link speed in units of Mbits/sec, either 0, 10, 100, or 1000.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On successful completion, XLlTemac_GetSgmiiStatus returns XST_SUCCESS. Otherwise, if TEMAC channel is not using an SGMII interface, XLlTemac_GetSgmiiStatus returns XST_NO_FEATURE.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a0" doxytag="xlltemac_control.c::XLlTemac_MulticastAdd"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">XStatus XLlTemac_MulticastAdd           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>AddressPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Entry</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
in the TEMAC channel's multicast filter list.<p>
XLlTemac_MulticastAdd adds the Ethernet address, <em>AddressPtr</em> to the TEMAC channel's multicast filter list, at list index <em>Entry</em>. The address referenced by <em>AddressPtr</em> may be of any unicast, multicast, or broadcast address form. The harware for the TEMAC channel can hold up to XTE_MULTI_MAT_ENTRIES addresses in this filter list.<br>
<br>
<p>
The device must be stopped to use this function.<br>
<br>
<p>
Once an Ethernet address is programmed, the TEMAC channel will begin receiving data sent from that address. The TEMAC hardware does not have a control bit to disable multicast filtering. The only way to prevent the TEMAC channel from receiving messages from an Ethernet address in the Multicast Address Table (MAT) is to clear it with <a class="el" href="xlltemac_8h.html#a70">XLlTemac_MulticastClear()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is a pointer to the 6-byte Ethernet address to set. The previous address at the location <em>Entry</em> (if any) is overwritten with the value at <em>AddressPtr</em>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Entry</em>&nbsp;</td><td>is the hardware storage location to program this address and must be between 0..XTE_MULTI_MAT_ENTRIES-1.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On successful completion, XLlTemac_MulticastAdd returns XST_SUCCESS. Otherwise, if the TEMAC channel is not stopped, XLlTemac_MulticastAdd returns XST_DEVICE_IS_STARTED.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="xlltemac_control.c::XLlTemac_MulticastClear"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">XStatus XLlTemac_MulticastClear           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Entry</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_MulticastClear clears the Ethernet address stored at index <em>Entry</em> in the TEMAC channel's multicast filter list.<br>
<br>
<p>
The device must be stopped to use this function.<br>
<br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Entry</em>&nbsp;</td><td>is the HW storage location used when this address was added. It must be between 0..XTE_MULTI_MAT_ENTRIES-1. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Entry</em>&nbsp;</td><td>is the hardware storage location to clear and must be between 0..XTE_MULTI_MAT_ENTRIES-1.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On successful completion, XLlTemac_MulticastClear returns XST_SUCCESS. Otherwise, if the TEMAC channel is not stopped, XLlTemac_MulticastClear returns XST_DEVICE_IS_STARTED.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a1" doxytag="xlltemac_control.c::XLlTemac_MulticastGet"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">void XLlTemac_MulticastGet           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>AddressPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>Entry</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_MulticastGet gets the Ethernet address stored at index <em>Entry</em> in the TEMAC channel's multicast filter list.<br>
<br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>references the memory buffer to store the retrieved Ethernet address. This memory buffer must be at least 6 bytes in length. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Entry</em>&nbsp;</td><td>is the hardware storage location from which to retrieve the address and must be between 0..XTE_MULTI_MAT_ENTRIES-1.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>N/A</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a5" doxytag="xlltemac_control.c::XLlTemac_SendPausePacket"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">XStatus XLlTemac_SendPausePacket           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>u16&nbsp;</td>
          <td class="mdname" nowrap> <em>PauseValue</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_SendPausePacket sends a pause packet with the value of <em>PauseValue</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>PauseValue</em>&nbsp;</td><td>is the pause value in units of 512 bit times.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On successful completion, XLlTemac_SendPausePacket returns XST_SUCCESS. Otherwise, if the TEMAC channel is not started, XLlTemac_SendPausePacket returns XST_DEVICE_IS_STOPPED.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="xlltemac_control.c::XLlTemac_SetMacPauseAddress"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">XStatus XLlTemac_SetMacPauseAddress           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="struct_x_ll_temac.html">XLlTemac</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>InstancePtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>AddressPtr</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
XLlTemac_SetMacPauseAddress sets the MAC address used for pause frames to <em>AddressPtr</em>. <em>AddressPtr</em> will be the address the TEMAC channel will recognize as being for pause frames. Pause frames transmitted with <a class="el" href="xlltemac_8h.html#a60">XLlTemac_SendPausePacket()</a> will also use this address.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>InstancePtr</em>&nbsp;</td><td>references the TEMAC channel on which to operate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>AddressPtr</em>&nbsp;</td><td>is a pointer to the 6-byte Ethernet address to set.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>On successful completion, XLlTemac_SetMacPauseAddress returns XST_SUCCESS. Otherwise, if the TEMAC channel is not stopped, XLlTemac_SetMacPauseAddress returns XST_DEVICE_IS_STARTED.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
This routine accesses the hard TEMAC registers through a shared interface between both channels of the TEMAC. Becuase of this, the application/OS code must provide mutual exclusive access to this routine with any of the other routines in this TEMAC driverr.     </td>
  </tr>
</table>
<p class="Copyright">
Copyright &copy; 1995-2008 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>

