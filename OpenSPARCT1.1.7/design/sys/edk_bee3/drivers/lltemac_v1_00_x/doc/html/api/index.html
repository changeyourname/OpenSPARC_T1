<html>
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>
	Xilinx Driver lltemac v1_00_b: lltemac v1_00_b
</title>
<link href="../../../../../../../doc/usenglish/css/driver_api_doxygen.css" rel="stylesheet" type="text/css">
</head>
<h3 class="PageHeader">Xilinx Processor IP Library</h3>
<hl>Software Drivers</hl>
<hr class="whs1">

<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindexHL" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<h1>lltemac v1_00_b </h1>
<p>
The Xilinx Tri-Mode Ethernet driver component. This driver supports the Virtex-5(TM) and Virtex-4(TM) 10/100/1000 MAC (TEMAC).<p>
For a full description of TEMAC features, please see the hardware spec. This driver supports the following features:<ul>
<li>Memory mapped access to host interface registers</li><li>Virtual memory support</li><li>Unicast, broadcast, and multicast receive address filtering</li><li>Full duplex operation (half duplex not supported)</li><li>Automatic source address insertion or overwrite (programmable)</li><li>Automatic PAD &amp; FCS insertion and stripping (programmable)</li><li>Flow control</li><li>VLAN frame support</li><li>Pause frame support</li><li>Jumbo frame support</li><li>Checksum offload</li></ul>
<p>
<h2>Driver Description</h2>
<p>
The device driver enables higher layer software (e.g., an application) to configure a TEMAC channel. It is intended that this driver be used in cooperation with another driver (FIFO or DMA) for data communication. This device driver can support multiple devices even when those devices have significantly different configurations.<p>
<h2>Initialization &amp; Configuration</h2>
<p>
The <a class="el" href="struct_x_ll_temac___config.html">XLlTemac_Config</a> structure can be used by the driver to configure itself. This configuration structure is typically created by the tool-chain based on hardware build properties, although, other methods are allowed and currently used in some systems.<p>
To support multiple runtime loading and initialization strategies employed by various operating systems, the driver instance can be initialized using the XLlTemac_CfgInitialze() routine.<p>
<h2>Interrupts and Asynchronous Callbacks</h2>
<p>
The driver has no dependencies on the interrupt controller. It provides no interrupt handlers. The application/OS software should set up its own interrupt handlers if required.<p>
<h2>Device Reset</h2>
<p>
When a TEMAC channel is connected up to a FIFO or DMA core in hardware, errors may be reported on one of those cores (FIFO or DMA) such that it can be determined that the TEMAC channel needs to be reset. If a reset is performed, the calling code should also reconfigure and reapply the proper settings in the TEMAC channel.<p>
When a TEMAC channel reset is required, <a class="el" href="xlltemac_8c.html#a5">XLlTemac_Reset()</a> should be utilized.<p>
<h2>Virtual Memory</h2>
<p>
This driver may be used in systems with virtual memory support by passing the appropriate value for the <em>EffectiveAddress</em> parameter to the <a class="el" href="xlltemac_8c.html#a2">XLlTemac_CfgInitialize()</a> routine.<p>
<h2>Transfering Data</h2>
<p>
The TEMAC core by itself is not cabable of transmitting or receiving data in any meaninful way. Instead one or both TEMAC channels need to be connected to a FIFO or DMA core in hardware.<p>
This TEMAC driver is modeled in a similar fashion where the application code or O/S adapter driver needs to make use of a separte FIFO or DMA driver in connection with this driver to establish meaningful communication over ethernet.<p>
<h2>Checksum Offloading</h2>
<p>
If configured, the device can compute a 16-bit checksum from frame data. In most circumstances this can lead to a substantial gain in throughput.<p>
The checksum offload settings for each frame sent or recieved are transmitted through the LocalLink interface in hardware. What this means is that the checksum offload feature is indirectly controlled in the TEMAC channel through the driver for the FIFO or DMA core connected to the TEMAC channel.<p>
Refer to the documentation for the FIFO or DMA driver used for data communication on how to set the values for the relevant LocalLink header words.<p>
Since this hardware implementation is general purpose in nature system software must perform pre and post frame processing to obtain the desired results for the types of packets being transferred. Most of the time this will be TCP/IP traffic.<p>
TCP/IP and UDP/IP frames contain separate checksums for the IP header and UDP/TCP header+data. With this hardware implementation, the IP header checksum cannot be offloaded. Many stacks that support offloading will compute the IP header if required and use hardware to compute the UDP/TCP header+data checksum. There are other complications concerning the IP pseudo header that must be taken into consideration. Readers should consult a TCP/IP design reference for more details.<p>
There are certain device options that will affect the checksum calculation performed by hardware for Tx:<p>
<ul>
<li>FCS insertion disabled (XTE_FCS_INSERT_OPTION): software is required to calculate and insert the FCS value at the end of the frame, but the checksum must be known ahead of time prior to calculating the FCS. Therefore checksum offloading cannot be used in this situation.</li></ul>
<p>
And for Rx:<p>
<ul>
<li>FCS/PAD stripping disabled (XTE_FCS_STRIP_OPTION): The 4 byte FCS at the end of frame will be included in the hardware calculated checksum. software must subtract out this data.</li></ul>
<p>
<ul>
<li>FCS/PAD stripping disabled (XTE_FCS_STRIP_OPTION): For frames smaller than 64 bytes, padding will be included in the hardware calculated checksum. software must subtract out this data. It may be better to allow the TCP/IP stack verify checksums for this type of packet.</li></ul>
<p>
<ul>
<li>VLAN enabled (XTE_VLAN_OPTION): The 4 extra bytes in the Ethernet header affect the hardware calculated checksum. software must subtract out the 1st two 16-bit words starting at the 15th byte.</li></ul>
<p>
<h3>Transmit Checksum Offloading</h3>
<p>
For transmit, the software can specify where in the frame the checksum calculation is to start, where the result should be inserted, and a seed value. The checksum is calculated from the start point through the end of frame.<p>
The checsum offloading settings are sent in the transmit LocalLink header words. The relevant LocalLink header words are described in brief below. Refer to the XPS_LL_TEMAC v1.00a hardware specification for more details.<p>
<h4>LocalLink header word 3:</h4>
<p>
<pre>
   Bits    31 (MSB): Transmit Checksum Enable: 1 - enabled, 0 - disabled
   Bits  0-30 (LSB): Reserved
   </pre><p>
<h4>LocalLink header word 4:</h4>
<p>
<pre>
   Bits 16-31 (MSB): Transmit Checksum Insertion Point: Frame offset where the
                     computed checksum value is stored, which should be in the
                     TCP or UDP header
   Bits  0-15 (LSB): Transmit Checksum Calculation Starting Point: Offset
                     in the frame where checksum calculation should begin
   </pre><p>
<h4>LocalLink header word 5:</h4>
<p>
<pre>
   Bits 16-31 (MSB): Transmit Checksum Calculation Initial Value: Checksum
                     seed value
   Bits  0-15 (LSB): Reserved
   </pre><p>
<h3>Receive Checksum Offloading</h3>
<p>
For Receive, the 15th byte to end of frame is checksummed. This range of bytes is the entire Ethernet payload (for non-VLAN frames).<p>
The checsum offloading information is sent in the receive LocalLink header words. The relevant LocalLink header words are described in brief below. Refer to the XPS_LL_TEMAC v1.00a hardware specification for more details.<p>
<h4>LocalLink header word 6:</h4>
<p>
<pre>
   Bits 16-31 (MSB): Receive Raw Checksum: Computed checksum value
   Bits  0-15 (LSB): Reserved
   </pre><p>
<h2>PHY Communication</h2>
<p>
Prior to PHY access, the MDIO clock must be setup. This driver will set a safe default that should work with PLB bus speeds of up to 150 MHz and keep the MDIO clock below 2.5 MHz. If the user wishes faster access to the PHY then the clock divisor can be set to a different value (see <a class="el" href="xlltemac_8c.html#a13">XLlTemac_PhySetMdioDivisor()</a>).<p>
MII register access is performed through the functions XLlTemac_PhyRead() and XLlTemac_PhyWrite().<p>
<h2>Link Sync</h2>
<p>
When the device is used in a multispeed environment, the link speed must be explicitly set using <a class="el" href="xlltemac_8c.html#a12">XLlTemac_SetOperatingSpeed()</a> and must match the speed the PHY has negotiated. If the speeds are mismatched, then the MAC will not pass traffic.<p>
The application/OS software may use the AutoNegotiation interrupt to be notified when the PHY has completed auto-negotiation.<p>
<h2>Asserts</h2>
<p>
Asserts are used within all Xilinx drivers to enforce constraints on argument values. Asserts can be turned off on a system-wide basis by defining, at compile time, the NDEBUG identifier. By default, asserts are turned on and it is recommended that users leave asserts on during development. For deployment use -DNDEBUG compiler switch to remove assert code.<p>
<h2>Driver Errata</h2>
<p>
<ul>
<li>A dropped receive frame indication may be reported by the driver after calling <a class="el" href="xlltemac_8c.html#a4">XLlTemac_Stop()</a> followed by <a class="el" href="xlltemac_8c.html#a3">XLlTemac_Start()</a>. This can occur if a frame is arriving when stop is called.</li><li>On Rx with checksum offloading enabled and FCS/PAD stripping disabled, FCS and PAD data will be included in the checksum result.</li><li>On Tx with checksum offloading enabled and auto FCS insertion disabled, the user calculated FCS will be included in the checksum result.</li></ul>
<p>
<dl compact><dt><b>Note:</b></dt><dd></dd></dl>
Xilinx drivers are typically composed of two components, one is the driver and the other is the adapter. The driver is independent of OS and processor and is intended to be highly portable. The adapter is OS-specific and facilitates communication between the driver and an OS. <br>
<br>
 This driver is intended to be RTOS and processor independent. Any needs for dynamic memory management, threads or thread mutual exclusion, or cache control must be satisfied by the layer above this driver.<p>
<pre>
 MODIFICATION HISTORY:</pre><p>
<pre> Ver   Who  Date     Changes
 ----- ---- -------- -------------------------------------------------------
 1.00a jvb  11/10/06 First release
 1.00a rpm  06/08/07 Added interrupt IDs to config structure for convenience
 1.00b drg  02/08/08 Added MGT check to the reset routine
 </pre> <p class="Copyright">
Copyright &copy; 1995-2008 Xilinx, Inc. All rights reserved.
</p>
</body>
</html>

