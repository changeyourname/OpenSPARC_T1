



*** sunhv.c	
--- sunhv.opensparc-t1-fpga.c	
***************
*** 41,46 ****
--- 41,67 ----
  static char *con_write_page;
  static char *con_read_page;
  
+ 
+ 
+ #define OPENSPARC_T1_FPGA   1
+ 
+ 
+ #ifdef OPENSPARC_T1_FPGA
+ 
+ static int sunhv_console_polling_period = 5;
+ 
+ static int __init setup_sunhv_console_polling_period(char *str)
+ {
+         get_option(&str, &sunhv_console_polling_period);
+         return 1;
+ }
+ __setup("sunhv_console_polling_period=", setup_sunhv_console_polling_period);
+ 
+ static struct timer_list  sunhv_timer;
+ 
+ #endif /* #ifdef OPENSPARC_T1_FPGA */
+ 
+ 
  static int hung_up = 0;
  
  static void transmit_chars_putchar(struct uart_port *port, struct circ_buf *xmit)
***************
*** 520,525 ****
--- 541,565 ----
          .data   =       &sunhv_reg,
  };
  
+ 
+ #ifdef OPENSPARC_T1_FPGA
+ static void sunhv_console_poll(unsigned long data)
+ {
+         struct uart_port *port = sunhv_port;
+         struct tty_struct *tty;
+         unsigned long flags;
+ 
+         tty = receive_chars(port);
+         transmit_chars(port);
+ 
+         if (tty)
+                 tty_flip_buffer_push(tty);
+ 
+         mod_timer(&sunhv_timer, jiffies + sunhv_console_polling_period);
+ }
+ #endif /* ifdef OPENSPARC_T1_FPGA */
+ 
+ 
  static int __devinit hv_probe(struct of_device *op, const struct of_device_id *match)
  {
          struct uart_port *port;
***************
*** 579,588 ****
--- 619,641 ----
          if (err)
                  goto out_unregister_driver;
  
+ #ifndef OPENSPARC_T1_FPGA
+ 
          err = request_irq(port->irq, sunhv_interrupt, 0, "hvcons", port);
          if (err)
                  goto out_remove_port;
  
+ #else /* ifndef OPENSPARC_T1_FPGA */
+ 
+         /* Interrupts are not generated by the console device. Therefore polling is used. */
+ 
+         init_timer(&sunhv_timer);
+         sunhv_timer.function = sunhv_console_poll;
+         mod_timer(&sunhv_timer, jiffies + sunhv_console_polling_period);
+ 
+ #endif /* ifndef OPENSPARC_T1_FPGA */
+ 
+ 
          dev_set_drvdata(&op->dev, port);
  
          return 0;
